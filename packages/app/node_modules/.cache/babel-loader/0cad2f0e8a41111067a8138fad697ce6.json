{"ast":null,"code":"'use strict';\n\nmodule.exports = annotate;\n\nfunction annotate(fn) {\n  if (typeof fn !== 'function') {\n    throw new Error('Could not parse function signature for injection dependencies: Object is not a function');\n  }\n\n  if (!fn.length) return [];\n  var injects = /^()\\(?([^)=]*)\\)? *=>/.exec(fn + '') || /^[^(]+([^ \\(]*) *\\(([^\\)]*)\\)/.exec(fn + '');\n\n  if (!injects) {\n    throw new Error('Could not parse function signature for injection dependencies: ' + fn + '');\n  }\n\n  var argumentString = injects[2] // Strip multi-line comments:\n  // Uses the lazy-quantifier (.*?): http://www.rexegg.com/regex-quantifiers.html#lazy_solution\n  .replace(/\\/\\*[\\S\\s]*?\\*\\//g, ' ') // Strip single-line comments:\n  .replace(/\\/\\/.*/g, ' ');\n\n  function groupSubArguments(_, type, keys) {\n    return type + keys.split(',').map(function (arg) {\n      return arg && arg.trim();\n    }).filter(Boolean).join('@');\n  }\n\n  argumentString = argumentString.replace(/(\\{)([^}]*)\\}/g, groupSubArguments);\n  argumentString = argumentString.replace(/(\\[)([^}]*)\\]/g, groupSubArguments);\n  return argumentString.split(',').map(function (arg) {\n    return arg && arg.trim();\n  }).map(function (arg) {\n    if (arg[0] === '{') {\n      return arg.substring(1).split('@');\n    }\n\n    if (arg[0] === '[') {\n      return {\n        items: arg.substring(1).split('@')\n      };\n    }\n\n    return arg;\n  }).filter(Boolean);\n}","map":null,"metadata":{},"sourceType":"script"}