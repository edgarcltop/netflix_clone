{"ast":null,"code":"'use strict';\n\nvar base64 = require('base64-js');\n\nvar errors = require('./errors');\n\nvar Expr = require('./Expr');\n\nvar util = require('util');\n\nvar customInspect = util && util.inspect && util.inspect.custom;\nvar stringify = util && util.inspect || JSON.stringify;\n/**\n * FaunaDB value types. Generally, these classes do not need to be instantiated\n * directly; they can be constructed through helper methods in {@link module:query}.\n *\n * Instances of these classes will be returned in responses if the response object\n * contains these values. For example, a FaunaDB response containing\n *`{ \"@ref\": { \"id\": \"123\", \"class\": { \"@ref\": { \"id\": \"frogs\", \"class\": { \"@ref\": { \"id\": \"classes\" } } } } } }`\n * will be returned as `new values.Ref(\"123\", new values.Ref(\"frogs\", values.Native.CLASSES))`.\n *\n * See the [FaunaDB Query API Documentation](https://app.fauna.com/documentation/reference/queryapi#simple-type)\n * for more information.\n *\n * @module values\n */\n\n/**\n * Base type for FaunaDB value objects.\n *\n * @extends Expr\n * @abstract\n * @constructor\n */\n\nfunction Value() {}\n\nutil.inherits(Value, Expr);\n/**\n * FaunaDB ref.\n * See the [docs](https://app.fauna.com/documentation/reference/queryapi#special-type).\n *\n * @param {string} id\n *   The id portion of the ref.\n * @param {Ref} [clazz]\n *   The class portion of the ref.\n * @param {Ref} [database]\n *   The database portion of the ref.\n *\n * @extends module:values~Value\n * @constructor\n */\n\nfunction Ref(id, clazz, database) {\n  if (!id) throw new errors.InvalidValue('id cannot be null or undefined');\n  this.value = {\n    id: id\n  };\n  if (clazz) this.value['class'] = clazz;\n  if (database) this.value['database'] = database;\n}\n\nutil.inherits(Ref, Value);\n/**\n * Gets the class part out of the Ref.\n *\n * @member {string}\n * @name module:values~Ref#class\n */\n\nObject.defineProperty(Ref.prototype, 'class', {\n  get: function get() {\n    return this.value['class'];\n  }\n});\n/**\n * Gets the database part out of the Ref.\n *\n * @member {Ref}\n * @name module:values~Ref#database\n */\n\nObject.defineProperty(Ref.prototype, 'database', {\n  get: function get() {\n    return this.value['database'];\n  }\n});\n/**\n * Gets the id part out of the Ref.\n *\n * @member {Ref}\n * @name module:values~Ref#id\n */\n\nObject.defineProperty(Ref.prototype, 'id', {\n  get: function get() {\n    return this.value['id'];\n  }\n});\n/** @ignore */\n\nRef.prototype.toJSON = function () {\n  return {\n    '@ref': this.value\n  };\n};\n\nwrapToString(Ref, function () {\n  var constructors = {\n    classes: \"Class\",\n    databases: \"Database\",\n    indexes: \"Index\",\n    functions: \"Function\"\n  };\n\n  var toString = function toString(ref, prevDb) {\n    if (ref.class === undefined && ref.database === undefined) return ref.id.charAt(0).toUpperCase() + ref.id.slice(1) + '(' + prevDb + ')';\n    var constructor = constructors[ref.class.id];\n\n    if (constructor !== undefined) {\n      var db = ref.database !== undefined ? ', ' + ref.database.toString() : '';\n      return constructor + '(\"' + ref.id + '\"' + db + ')';\n    }\n\n    var db = ref.database !== undefined ? ref.database.toString() : '';\n    return 'Ref(' + toString(ref.class, db) + ', \"' + ref.id + '\")';\n  };\n\n  return toString(this, '');\n});\n/** @ignore */\n\nRef.prototype.valueOf = function () {\n  return this.value;\n};\n/**\n * Whether these are both Refs and have the same value.\n * @param {any} other\n * @returns {boolean}\n */\n\n\nRef.prototype.equals = function (other) {\n  return other instanceof Ref && this.id === other.id && (this.class === undefined && other.class === undefined || this.class.equals(other.class)) && (this.database === undefined && other.database === undefined || this.database.equals(other.database));\n};\n\nvar Native = {\n  CLASSES: new Ref('classes'),\n  INDEXES: new Ref('indexes'),\n  DATABASES: new Ref('databases'),\n  FUNCTIONS: new Ref('functions'),\n  KEYS: new Ref('keys')\n};\n\nNative.fromName = function (name) {\n  switch (name) {\n    case 'classes':\n      return Native.CLASSES;\n\n    case 'indexes':\n      return Native.INDEXES;\n\n    case 'databases':\n      return Native.DATABASES;\n\n    case 'functions':\n      return Native.FUNCTIONS;\n\n    case 'keys':\n      return Native.KEYS;\n  }\n\n  return new Ref(name);\n};\n/**\n * FaunaDB Set.\n * This represents a set returned as part of a response.\n * This looks like `{\"@set\": set_query}`.\n * For query sets see {@link match}, {@link union},\n * {@link intersection}, {@link difference}, and {@link join}.\n *\n * @extends module:values~Value\n * @constructor\n */\n\n\nfunction SetRef(value) {\n  /** Raw query object. */\n  this.value = value;\n}\n\nutil.inherits(SetRef, Value);\nwrapToString(SetRef, function () {\n  return 'SetRef(' + stringify(this.value) + ')';\n});\n/** @ignore */\n\nSetRef.prototype.toJSON = function () {\n  return {\n    '@set': this.value\n  };\n};\n/** FaunaDB time. See the [docs](https://app.fauna.com/documentation/reference/queryapi#special-type).\n *\n * @param {string|Date} value If a Date, this is converted to a string.\n * @extends module:values~Value\n * @constructor\n */\n\n\nfunction FaunaTime(value) {\n  if (value instanceof Date) {\n    value = value.toISOString();\n  } else if (!(value.charAt(value.length - 1) === 'Z')) {\n    throw new errors.InvalidValue('Only allowed timezone is \\'Z\\', got: ' + value);\n  }\n\n  this.value = value;\n}\n\nutil.inherits(FaunaTime, Value);\n/**\n * Returns the date wrapped by this object.\n * This is lossy as Dates have millisecond rather than nanosecond precision.\n *\n * @member {Date}\n * @name module:values~FaunaTime#date\n */\n\nObject.defineProperty(FaunaTime.prototype, 'date', {\n  get: function get() {\n    return new Date(this.value);\n  }\n});\nwrapToString(FaunaTime, function () {\n  return 'Time(\"' + this.value + '\")';\n});\n/** @ignore */\n\nFaunaTime.prototype.toJSON = function () {\n  return {\n    '@ts': this.value\n  };\n};\n/** FaunaDB date. See the [docs](https://app.fauna.com/documentation/reference/queryapi#special-type).\n *\n * @param {string|Date} value\n *   If a Date, this is converted to a string, with time-of-day discarded.\n * @extends module:values~Value\n * @constructor\n */\n\n\nfunction FaunaDate(value) {\n  if (value instanceof Date) {\n    // The first 10 characters 'YYYY-MM-DD' are the date portion.\n    value = value.toISOString().slice(0, 10);\n  }\n  /**\n   * ISO8601 date.\n   * @type {string}\n   */\n\n\n  this.value = value;\n}\n\nutil.inherits(FaunaDate, Value);\n/**\n * @member {Date}\n * @name module:values~FaunaDate#date\n */\n\nObject.defineProperty(FaunaDate.prototype, 'date', {\n  get: function get() {\n    return new Date(this.value);\n  }\n});\nwrapToString(FaunaDate, function () {\n  return 'Date(\"' + this.value + '\")';\n});\n/** @ignore */\n\nFaunaDate.prototype.toJSON = function () {\n  return {\n    '@date': this.value\n  };\n};\n/** FaunaDB bytes. See the [docs](https://app.fauna.com/documentation/reference/queryapi#special-type).\n *\n * @param {Uint8Array|ArrayBuffer|string} value\n *    If ArrayBuffer it's converted to Uint8Array\n *    If string it must be base64 encoded and it's converted to Uint8Array\n * @extends module:values~Value\n * @constructor\n */\n\n\nfunction Bytes(value) {\n  if (value instanceof ArrayBuffer) {\n    this.value = new Uint8Array(value);\n  } else if (typeof value === 'string') {\n    this.value = base64.toByteArray(value);\n  } else if (value instanceof Uint8Array) {\n    this.value = value;\n  } else {\n    throw new errors.InvalidValue('Bytes type expect argument to be either Uint8Array|ArrayBuffer|string, got: ' + stringify(value));\n  }\n}\n\nutil.inherits(Bytes, Value);\nwrapToString(Bytes, function () {\n  return 'Bytes(\"' + base64.fromByteArray(this.value) + '\")';\n});\n/** @ignore */\n\nBytes.prototype.toJSON = function () {\n  return {\n    '@bytes': base64.fromByteArray(this.value)\n  };\n};\n/** FaunaDB query. See the [docs](https://app.fauna.com/documentation/reference/queryapi#special-type).\n *\n * @param {any} value\n * @extends module:values~Value\n * @constructor\n */\n\n\nfunction Query(value) {\n  this.value = value;\n}\n\nutil.inherits(Query, Value);\nwrapToString(Query, function () {\n  return 'Query(' + Expr.toString(this.value) + ')';\n});\n/** @ignore */\n\nQuery.prototype.toJSON = function () {\n  return {\n    '@query': this.value\n  };\n};\n/** @ignore */\n\n\nfunction wrapToString(type, fn) {\n  type.prototype.toString = fn;\n  type.prototype.inspect = fn;\n\n  if (customInspect) {\n    type.prototype[customInspect] = fn;\n  }\n}\n\nmodule.exports = {\n  Value: Value,\n  Ref: Ref,\n  Native: Native,\n  SetRef: SetRef,\n  FaunaTime: FaunaTime,\n  FaunaDate: FaunaDate,\n  Bytes: Bytes,\n  Query: Query\n};","map":null,"metadata":{},"sourceType":"script"}