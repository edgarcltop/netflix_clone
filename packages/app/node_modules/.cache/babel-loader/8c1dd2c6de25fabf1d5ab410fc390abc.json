{"ast":null,"code":"'use strict';\n\nvar query = require('./query');\n\nvar objectAssign = require('object-assign');\n\nvar Promise = require('es6-promise').Promise;\n/**\n * A FaunaDB Lambda expression to be passed into one of the collection\n * functions: Map or Filter.\n *\n * @callback PageHelper~collectionFunction\n * @param {any} var\n *   The variable passed in by FaunaDB when this Lambda\n *   function is executed.\n * @return {Expr}\n *   The FaunaDB query expression to be returned by this Lambda.\n */\n\n/**\n * @callback PageHelper~eachFunction\n * @param {Object} page\n *   A page returned by FaunaDB's Paginate function.\n */\n\n/**\n * A wrapper that provides a helpful API for consuming FaunaDB pages.\n *\n * Generally this is constructed through the {@link Client#paginate} method.\n *\n * The {@link PageHelper#map} and {@link PageHelper#filter} methods will wrap the underlying query with a Map\n * and Filter query function, respectively. These will be executed on the server when a promise-returning function\n * is called.\n *\n * The {@link PageHelper#each} and {@link PageHelper#eachReverse} functions dispatch queries to FaunaDB, and return Promises\n * representing the completion of those queries. The callbacks provided to these functions are executed locally when the\n * queries return.\n *\n * The {@link PageHelper#nextPage} and {@link PageHelper#previousPage} functions also dispatch queries to FaunaDB,\n * but return their responses in a wrapped Promise.\n *\n * @param {Client} client\n *   The FaunaDB client used to paginate.\n * @param {Object} set\n *   The set to paginate.\n * @param {?Object} params\n *   Parameters to be passed to the FaunaDB Paginate function.\n * @constructor\n */\n\n\nfunction PageHelper(client, set, params) {\n  if (params === undefined) {\n    params = {};\n  }\n\n  this.reverse = false;\n  this.params = {};\n  this.before = undefined;\n  this.after = undefined;\n  objectAssign(this.params, params);\n\n  if ('before' in params) {\n    this.before = params.before;\n    delete this.params.before;\n  } else if ('after' in params) {\n    this.after = params.after;\n    delete this.params.after;\n  }\n\n  this.client = client;\n  this.set = set;\n  /**\n   * @member {Array.<Function>}\n   * @type {Array.<Function>}\n   * @private\n   */\n\n  this._faunaFunctions = [];\n}\n/**\n * Wraps the set to be paginated with a FaunaDB Map function.\n * As this function is executed on the server, the `lambda` param must\n * return a valid query expression.\n *\n * @param {PageHelper~collectionFunction} lambda\n *   The Lambda expression to be passed into the Map function.\n * @return {PageHelper}\n *\n */\n\n\nPageHelper.prototype.map = function (lambda) {\n  var rv = this._clone();\n\n  rv._faunaFunctions.push(function (q) {\n    return query.Map(q, lambda);\n  });\n\n  return rv;\n};\n/**\n * Wraps the set to be paginated with a FaunaDB Filter funciton.\n * As this function is executed on the server, the `lambda` param must\n * return a valid query expression.\n *\n * @param {PageHelper~collectionFunction} lambda\n *   The lambda expression to be passed into the Filter function.\n * @return {PageHelper}\n */\n\n\nPageHelper.prototype.filter = function (lambda) {\n  var rv = this._clone();\n\n  rv._faunaFunctions.push(function (q) {\n    return query.Filter(q, lambda);\n  });\n\n  return rv;\n};\n/**\n * Executes the provided function for each page.\n *\n * @param {PageHelper~eachFunction} lambda\n *   A function to be executed for each page.\n * @returns {external:Promise.<void>}\n */\n\n\nPageHelper.prototype.each = function (lambda) {\n  return this._retrieveNextPage(this.after, false).then(this._consumePages(lambda, false));\n};\n/**\n * Executes the provided function for each page, in the reverse direction.\n * @param {PageHelper~eachFunction} lambda\n * @returns {external:Promise.<void>}\n */\n\n\nPageHelper.prototype.eachReverse = function (lambda) {\n  return this._retrieveNextPage(this.before, true).then(this._consumePages(lambda, true));\n};\n/**\n * Queries for the previous page from the current cursor point; this mutates\n * the state of the PageHelper when the query completes, updating the internal\n * cursor state to that of the returned page.\n *\n * @returns {external:Promise.<object>}\n */\n\n\nPageHelper.prototype.previousPage = function () {\n  var self = this;\n  return this._retrieveNextPage(this.before, true).then(this._adjustCursors.bind(self));\n};\n/**\n * Queries for the next page from the current cursor point; this mutates\n * the state of the PageHelper when the query completes, updating the internal\n * cursor state to that of the returned page.\n *\n * @returns {external:Promise.<object>}\n */\n\n\nPageHelper.prototype.nextPage = function () {\n  var self = this;\n  return this._retrieveNextPage(this.after, false).then(this._adjustCursors.bind(self));\n};\n\nPageHelper.prototype._adjustCursors = function (page) {\n  if (page.after !== undefined) {\n    this.after = page.after;\n  }\n\n  if (page.before !== undefined) {\n    this.before = page.before;\n  }\n\n  return page.data;\n};\n\nPageHelper.prototype._consumePages = function (lambda, reverse) {\n  var self = this;\n  return function (page) {\n    lambda(page.data);\n    var nextCursor;\n\n    if (reverse) {\n      nextCursor = page.before;\n    } else {\n      nextCursor = page.after;\n    }\n\n    if (nextCursor !== undefined) {\n      return self._retrieveNextPage(nextCursor, reverse).then(self._consumePages(lambda, reverse));\n    } else {\n      return Promise.resolve();\n    }\n  };\n};\n/**\n *\n * @returns {external:Promise.<Object>}\n * @private\n */\n\n\nPageHelper.prototype._retrieveNextPage = function (cursor, reverse) {\n  var opts = {};\n  objectAssign(opts, this.params);\n\n  if (cursor !== undefined) {\n    if (reverse) {\n      opts.before = cursor;\n    } else {\n      opts.after = cursor;\n    }\n  } else {\n    if (reverse) {\n      opts.before = null;\n    }\n  }\n\n  var q = query.Paginate(this.set, opts);\n\n  if (this._faunaFunctions.length > 0) {\n    this._faunaFunctions.forEach(function (lambda) {\n      q = lambda(q);\n    });\n  }\n\n  return this.client.query(q);\n};\n/**\n * @private\n * @returns {PageHelper}\n */\n\n\nPageHelper.prototype._clone = function () {\n  return Object.create(PageHelper.prototype, {\n    client: {\n      value: this.client\n    },\n    set: {\n      value: this.set\n    },\n    _faunaFunctions: {\n      value: this._faunaFunctions\n    },\n    before: {\n      value: this.before\n    },\n    after: {\n      value: this.after\n    }\n  });\n};\n\nmodule.exports = PageHelper;","map":null,"metadata":{},"sourceType":"script"}